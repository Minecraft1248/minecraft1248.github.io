<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2022/12/03/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a class="link" href="https://hexo.io/">Hexo<i class="fas fa-external-link-alt"></i></a>! This is your very first post. Check <a class="link" href="https://hexo.io/docs/">documentation<i class="fas fa-external-link-alt"></i></a> for more info. If you get any problems when using Hexo, you can find the answer in <a class="link" href="https://hexo.io/docs/troubleshooting.html">troubleshooting<i class="fas fa-external-link-alt"></i></a> or you can ask me on <a class="link" href="https://github.com/hexojs/hexo/issues">GitHub<i class="fas fa-external-link-alt"></i></a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link" href="https://hexo.io/docs/writing.html">Writing<i class="fas fa-external-link-alt"></i></a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link" href="https://hexo.io/docs/server.html">Server<i class="fas fa-external-link-alt"></i></a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link" href="https://hexo.io/docs/generating.html">Generating<i class="fas fa-external-link-alt"></i></a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link" href="https://hexo.io/docs/one-command-deployment.html">Deployment<i class="fas fa-external-link-alt"></i></a></p>
]]></content>
  </entry>
  <entry>
    <title>C++究竟是一门什么样的语言</title>
    <url>/2022/12/24/C++%E7%A9%B6%E7%AB%9F%E6%98%AF%E4%B8%80%E9%97%A8%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E8%AF%AD%E8%A8%80/</url>
    <content><![CDATA[<h1 id="C-究竟是一门什么样的语言"><a href="#C-究竟是一门什么样的语言" class="headerlink" title="C++究竟是一门什么样的语言"></a>C++究竟是一门什么样的语言</h1><h2 id="——C-的过去，现在与未来"><a href="#——C-的过去，现在与未来" class="headerlink" title="——C++的过去，现在与未来"></a>——C++的过去，现在与未来</h2><h2 id="第一部分：前言"><a href="#第一部分：前言" class="headerlink" title="第一部分：前言"></a>第一部分：前言</h2><h3 id="”C-是什么？“之谜"><a href="#”C-是什么？“之谜" class="headerlink" title="”C++是什么？“之谜"></a>”C++是什么？“之谜</h3><p>想象一下，如果你是一个刚刚开始准备学习C++的新人，此时你正在翻阅你买来的一本《C++ Primer Plus》，对C++一无所知的你对所看到的内容起了一种本能上对数学课般枯燥文字的睡意，虽然看不太懂，但你从这本书惊为天人的厚度中隐约的觉察到了“C++”这三字背后蕴含的一些不一样的东西。为了弄清楚C++这门语言，你想起了一群程序员前辈，于是你拿起手机，开始一个个的问他们：“C++是什么？”。</p>
<p>你首先问了一个主要学Java的学长，他的回答是这样的：</p>
<p>“第一眼看过去，你可能认为C++和Java差不多，但很多时候两门语言只是看着像，两门语言的大方向其实是不同的。一般来说，Java比较安全，因为Java作为一门有虚拟机垫着的托管语言，不需要像C++一样处理很多跟计算机底层有关的概念，比如指针这类，不仅比较难理解还容易误用。但C++也不是完全不如Java，相比之下，C++的灵活性更强，并且速度通常更快。”</p>
<p>听完这个，你对C++开始有一点认识了，“灵活”，“快”但是“不安全”，但你又有点担心，因为单就这几个形容词，似乎还配不上桌子上那本摊开的砖头的厚度，于是你抱着试试的心态，问了一个学C语言的朋友：</p>
<p>“虽然在外行看来，C语言和C++一直处于不分家的状态，但是我要告诉你，除非你真的要学，C语言就够你的了。C++那帮子人最喜欢用丑的不行的语法来封装C语言的玩意，比如那什么，好像叫什么STL吧，说实话看着就难受。C++如果非要用的话最好就只用类就行了，其他的问题C语言都能解决。”</p>
<p>看得出来你朋友的心情不太好（可能又有野指针没抓出来），你决定还是先不打扰他。虽然如此，在通讯录上查找另外一个学一门你没怎么见过的语言（好像叫做什么Rust）的学弟的时候，脑袋里全是刚才朋友话里的几个词：“没必要学”，“语法丑陋”，想着这几个词的意义的时候，那个学Rust的学弟回你了：</p>
<p>“说实话吧，我觉得跟C++一比，Rust真是太优美了，Rust里面能够完美避开的问题，比如内存泄漏啊，类型安全啊。而且吧C++的语法不仅复杂，还特别臃肿，你能想象一个语言连初始化一个整数变量都有4种写法吗？而且要是这四种写法只有写法上的区别还好，语义上还不一样！还好你没开始学，不然我估计你学到模板的时候都不想学了。如果你真要学编程的我还是推荐你来跟我一起学Rust，我还可以带你。”</p>
<p>从自己的朋友那里得到这种级别的否定，你开始怀疑自己花这么多钱买本没人看的砖头的合理性，但本着不能白花钱的心态，你还是上百度查了查相关问题，当然结果大家肯定都知道了，除了批评还是批评——</p>
<p>“还在用c++？我们都用rust去了”</p>
<p>“说实话这代码是真的绕”</p>
<p>“看完我只感觉c#简单多了”</p>
<p>“C++最大的敌人是不做人的标准委员会！”</p>
<p>然后心烦意乱的你只能把《C++ Primer Plus》放到书架上，彻底打消了学习C++的念头。</p>
<p>我相信，以上这种经历，很多人都经历过。并且这还是一个比较温和的版本，如果这个新人一连问了好几个学习C++的人，他只会更加崩溃——他们给出的答案甚至是相互矛盾的！这些令人迷惑而相互矛盾的对“C++是什么？”问题的各式各样的回答已经持续了数十年——事实上从C++诞生起就一直存在着。而这些回答无疑很大程度上造就了一种普遍的对C++错误的认识：”一门过于灵活，语法臃肿，思想落后的语言“或者其类似版本。并且尤其是近几年一种经常被大声宣扬的观点之《为什么C++没有生态位》，则进一步加剧了大众对C++的负面评价：</p>
<ul>
<li>“低级编程”可以由少量的 C 或汇编代码处理。</li>
<li>“高级编程”则可以使用一种带有巨大的运行时支持系统的更安全、更小并使用垃圾收集的语言来做，这样可以更好、更便宜、更高效地完成。</li>
<li>像 Java 和 C# 这样的托管语言使用垃圾收集和一致的运行期范围检查，使得不太专业的程序员能更有生产力，这样可以减少对高技能的开发人员的需求。</li>
<li>编程语言与平台的深度集成，并使用集成工具来进行支持，这对生产力和大型系统的构建至关重要。</li>
</ul>
<p>我猜你现在在纳闷”难道不是这样吗？“，但这些观点毫无疑问是错误的——至少我否认这些，并且如果上述观点如果正确，哪怕只需要一条是对的，C++都活不到今天。至于为什么这些观点是错误的，就是接下来我们要讲的内容了。</p>
<h3 id="在开始正式讲解之前，你需要记住一些东西"><a href="#在开始正式讲解之前，你需要记住一些东西" class="headerlink" title="在开始正式讲解之前，你需要记住一些东西"></a>在开始正式讲解之前，你需要记住一些东西</h3><h2 id="第二部分：C-的过去，现在与未来"><a href="#第二部分：C-的过去，现在与未来" class="headerlink" title="第二部分：C++的过去，现在与未来"></a>第二部分：C++的过去，现在与未来</h2><h3 id="2-1-C-的古典时代（Cfront时代，C-98与C-03）"><a href="#2-1-C-的古典时代（Cfront时代，C-98与C-03）" class="headerlink" title="2.1 C++的古典时代（Cfront时代，C++ 98与C++ 03）"></a>2.1 C++的古典时代（Cfront时代，C++ 98与C++ 03）</h3><h4 id="C语言的起源"><a href="#C语言的起源" class="headerlink" title="C语言的起源"></a>C语言的起源</h4><p>20世纪60年代，AT&amp;T贝尔实验室的一名研究员肯·汤普森（Kenneth Lane Thompson）闲来无事，手痒难耐，他想玩一个自己写的模拟太阳系航行的电子游戏：Space Travel。说到这个游戏，就不得不提一嘴这个游戏的来头：汤普森原本属于一个由贝尔实验室，麻省理工学院和通用电气公司联合开发的Multics系统项目，他的游戏也自然是基于Multics系统，但后来由于贝尔实验室撤出了该项目，汤普森也失去了可以运行自己游戏的平台。上班摸不了鱼了，汤普森很是难受，为了让自己可以愉快的划水，汤普森背着老板找到了一台小型计算机PDP-7。然而，在汤普森以为万事大吉，准备开摸的时候，他发现了一个小问题：PDP-7没有操作系统。这个问题在现在很好解决，毕竟都2022年了，只要跟计算机扯上关系的东西都可以找到一个操作系统。但是在计算机刚刚起步的20世纪60年代，连硬件都没有统一标准，大家都是各干各的，更别提刚有个雏形的操作系统了。于是，为了解决自己上班摸鱼的问题，汤普森决定：没有操作系统没关系，我自己写一个！于是，UNICS系统，也就是日后的UNIX，就如此诞生了。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://www.img.xz95.top/img/wikipedia/commons/4/46/Space_Travel_Screenshot.png"
                      alt="星际旅行"
                ></p>
<p><em>Space Travel游戏画面</em></p>
<p>为了给PDP-7开发操作系统，汤普森还基于当时的一门编程语言BCPL设计了BCPL的精简版，这个语言被称为B语言。在汤普森努力为计算机研究事业献身（大嘘）时，PDP-11出现了，由于当时计算机厂家普遍没有兼容意识，原本在PDP-7上跑的好好的UNICS，放到PDP-11上面就成了废物。为了可以在更好的电脑上为实验室创造学术价值，汤普森与一位同样酷爱Space Travel的同事丹尼斯·里奇（Dennis MacAlistair Ritchie）开始着手将UNICS移植到PDP-11上。在移植过程中，两人发现了一个严重问题：PDP-11提供了不同大小的基本对象，如一个字节长的字符，两字节长的整数和四字节长的浮点数，而用于UNICS系统开发的B语言并不能很好的处理这些对象。面对这个问题，里奇向B语言加入了我们今天耳熟能详的一个概念——数据类型，也就是我们在各种现代语言上习以为常的<code>int</code>,<code>char</code>,<code>bool</code>等，里奇认为这门语言需要一个名字，于是，1972年，C语言产生了。</p>
<p>C语言一经推出，就引爆了整个编程界，C语言当中的大量特性，如静态类型系统，结构化编程，结构体等，在当时看来都是极为先进和新奇的特性。一时间使用C语言成为了计算机圈子当中的一股热潮。早已忘记了自己原来是来上班玩游戏的里奇与布莱恩·柯林汉（Brian Kernighan）于1978年合作出版了《C程序设计语言》的第一版，事实上也奠定了C语言的惯用标准，这个标准后来被称之为K&amp;R C。</p>
<h4 id="面向过程的危机和C-的第一个十年"><a href="#面向过程的危机和C-的第一个十年" class="headerlink" title="面向过程的危机和C++的第一个十年"></a>面向过程的危机和C++的第一个十年</h4><p>C语言无疑是一门极其成功的语言，但是，C语言有一个在现在看来非常严重的缺陷：C语言是一门面向过程的语言。</p>
<p>随着时间的流逝，C语言作为一门面向过程语言的弊端逐渐显现（如代码复用不方便，大型项目代码难以维护等）。为了解决C语言所凸显出的面向过程语言的通病，一种叫做面向对象的编程范式逐渐发展起来<em>也许要介绍一下面向过程和面向对象？</em>。在这一时期各种采用面向对象的语言开始发展，其中一门称作Simula的语言引起了一位计算机科学博士的注意，这个博士，有一个读起来就让人感觉不一般的名字：比雅尼·斯特劳斯特鲁普（Bjarne Stroustrup）。</p>
<p>斯特劳斯特鲁普根据自己在撰写自己的博士论文时候的一些程序编写经验，认为Simula语言的引入的一些新奇概念很适合开发大型软件，这些概念包括（此处Simula指Simula 67）：</p>
<ul>
<li><p>对象（Object）</p>
</li>
<li><p>类（Class）</p>
</li>
<li><p>继承（Inheritance）</p>
</li>
<li><p>引用（Reference）</p>
</li>
<li><p>虚（Virtual）类，虚函数等虚过程</p>
</li>
</ul>
<p>但在拥有完全面向对象的特性的同时，斯特劳斯特鲁普也发现Simula语言的执行速度太慢，很难在现实应用中发挥作用，正好当时正处于热门的C语言的一大专长就是无与伦比的运行速度，于是一个想法开始在这个29岁的计算机博士的脑海当中形成：为什么不把Simula的面向对象与C语言的速度结合起来，造就一门既高效又有着有力的抽象工具的语言呢？斯特劳斯特鲁普在日后这样描述他发明C++的想法：“我的目标是设计一个工具，它既拥有直接而高效的处理硬件的能力（例如编写内存管理器、进程调度器和设备驱动程序），又同时可以有类似 Simula 的功能来组织代码（例如“强”静态可扩展类型检查、类、多级类和协程）。我想用这个工具编写一版 Unix 内核（我们又绕回到了Unix系统！），可以在通过局域网或共享内存互联的多个处理器上运行。”</p>
<p>至于为什么选择了C语言，斯特劳斯特鲁普在他的一篇论文中如此描述：</p>
<ul>
<li><p>C语言是<strong>灵活</strong>的语言：你可以在任何应用领域用上C语言，在C语言上使用几乎所有编程技巧，换而言之，C语言没有任何内在的限制来限制你使用这门语言的方式</p>
</li>
<li><p>C语言是<strong>高效</strong>的语言：C语言当中的基础概念，都反映了计算机底层的相应概念，这让C语言程序员可以轻松且优雅的使用底层资源</p>
</li>
<li><p>C语言是<strong>通用</strong>的语言：世界上所有的计算机，无论是最小的单片机还是最大的超级计算机，总会有个可以用的C编译器和标准库，以及一大串第三方库和支持工具</p>
</li>
<li><p>C语言是<strong>跨平台</strong>的语言：虽然C语言编译出的可执行文件通常无法跨平台，但是将一个平台上正常运行的C代码转换成在另一个平台上运行的成本通常较小（有的时候甚至不用改）</p>
</li>
<li><p>里奇和柯林汉的办公室就在斯特劳斯特鲁普办公室走廊对面，三个人经常一起吃午饭（强者之间的相互吸引orz）</p>
</li>
</ul>
<p>带着发明新语言的想法，1979年4月，一门叫做C with Classes（带类的C）的语言出现了。C with Classes在C语言语法的基础上加入了如类，派生类，存储类型检查，内联和缺省参数等特性。因为这时候C++还没有第一个真正意义上的编译器，而是通过一个称之为Cfront的翻译器将C with Classes的代码翻译为等价的C语言代码，再将翻译出的C语言代码通过C编译器编译，这个时期也被称之为Cfront时期。随后C with Classes通过Cfront自举实现了第一个真正意义上的编译器，并于1983年改名为我们最熟悉的名字，也是本期视频的主角：C++</p>
<p>直到1989年C++标准委员会成立之前，C++一直保持着与C的高度兼容，并先后引入了如虚函数，引用，运算符与函数重载，抽象类，模板，异常等，并于1985年发布了第一版《C++程序设计语言》，从而给C++提供了第一个较为权威的语言基础。</p>
<p>带着新加入的诸多新特性，C++的社区从一开始的十几个人急剧增长到数十万人，C++，迎来了第一个语言发展历史上的高峰，C++凭借着与C语言相近的性能和自身作为面向对象（传统类型上的）语言，在工业界的使用中占了相当大的份额。同时随着C++语言的发展壮大，面向对象这一重要的编程范式真正得到了普及。</p>
<h4 id="C-的第二个十年"><a href="#C-的第二个十年" class="headerlink" title="C++的第二个十年"></a>C++的第二个十年</h4><h3 id="2-2-何为C-标准委员会？"><a href="#2-2-何为C-标准委员会？" class="headerlink" title="2.2 何为C++标准委员会？"></a>2.2 何为C++标准委员会？</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://isocpp.org/files/img/wg21-1990-2020.png"
                     
                ></p>
<p><em>在此致敬C++标准委员会，C语言标准委员会以及C&#x2F;C++联络组的所有成员，没有你们，就不会有这两门编程史上堪称传奇的编程语言</em></p>
<h3 id="2-3-C-11：像一门新语言"><a href="#2-3-C-11：像一门新语言" class="headerlink" title="2.3 C++ 11：像一门新语言"></a>2.3 C++ 11：像一门新语言</h3><h3 id="2-4-C-14：完善C-11"><a href="#2-4-C-14：完善C-11" class="headerlink" title="2.4 C++ 14：完善C++ 11"></a>2.4 C++ 14：完善C++ 11</h3><h3 id="2-5-C-17：大海迷航"><a href="#2-5-C-17：大海迷航" class="headerlink" title="2.5 C++ 17：大海迷航"></a>2.5 C++ 17：大海迷航</h3><h3 id="2-6-C-20：方向之争"><a href="#2-6-C-20：方向之争" class="headerlink" title="2.6 C++ 20：方向之争"></a>2.6 C++ 20：方向之争</h3><h3 id="2-7-C-23-amp-future：旭日初升还是夕阳余晖？"><a href="#2-7-C-23-amp-future：旭日初升还是夕阳余晖？" class="headerlink" title="2.7 C++ 23&amp;future：旭日初升还是夕阳余晖？"></a>2.7 C++ 23&amp;future：旭日初升还是夕阳余晖？</h3><h2 id="第三部分：尾声"><a href="#第三部分：尾声" class="headerlink" title="第三部分：尾声"></a>第三部分：尾声</h2><h3 id="3-1-结语"><a href="#3-1-结语" class="headerlink" title="3.1 结语"></a>3.1 结语</h3><h3 id="3-2-参考文献"><a href="#3-2-参考文献" class="headerlink" title="3.2 参考文献"></a>3.2 参考文献</h3><ul>
<li><p>Stroustrup B. Thriving in a crowded and changing world: C++ 2006–2020[J]. Proceedings of the ACM on Programming Languages, 2020, 4(HOPL): 1-168.</p>
</li>
<li><p>Stroustrup B. A history of C++ 1979–1991[M]&#x2F;&#x2F;History of programming languages—II. 1996: 699-769.</p>
</li>
<li><p>Stroustrup B. Evolving a language in and for the real world: C++ 1991-2006[C]&#x2F;&#x2F;Proceedings of the third ACM SIGPLAN conference on History of programming languages. 2007: 4-1-4-59.</p>
</li>
<li><p>Stroustrup B. The C++ programming language[M]. Pearson Education, 2013.</p>
</li>
</ul>
]]></content>
      <categories>
        <category>C++教程</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
</search>
